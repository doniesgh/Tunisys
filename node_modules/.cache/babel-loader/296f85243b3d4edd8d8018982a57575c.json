{"ast":null,"code":"import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\n\nasync function embedProp(propName, node, options) {\n  var _a;\n\n  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options);\n    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n    return true;\n  }\n\n  return false;\n}\n\nasync function embedBackground(clonedNode, options) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options);\n  }\n\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options);\n  }\n}\n\nasync function embedImageNode(clonedNode, options) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n\n  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {\n    return;\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve;\n    clonedNode.onerror = reject;\n    const image = clonedNode;\n\n    if (image.decode) {\n      image.decode = resolve;\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager';\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = '';\n      clonedNode.src = dataURL;\n    } else {\n      clonedNode.href.baseVal = dataURL;\n    }\n  });\n}\n\nasync function embedChildren(clonedNode, options) {\n  const children = toArray(clonedNode.childNodes);\n  const deferreds = children.map(child => embedImages(child, options));\n  await Promise.all(deferreds).then(() => clonedNode);\n}\n\nexport async function embedImages(clonedNode, options) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options);\n    await embedImageNode(clonedNode, options);\n    await embedChildren(clonedNode, options);\n  }\n}","map":{"version":3,"mappings":"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","names":["embedResources","toArray","isInstanceOfElement","isDataUrl","resourceToDataURL","getMimeType","embedProp","propName","node","options","propValue","style","_a","getPropertyValue","cssString","setProperty","getPropertyPriority","embedBackground","clonedNode","embedImageNode","isImageElement","HTMLImageElement","src","SVGImageElement","href","baseVal","url","dataURL","Promise","resolve","reject","onload","onerror","image","decode","loading","srcset","embedChildren","children","childNodes","deferreds","map","child","embedImages","all","then","Element"],"sources":["C:\\Users\\donia\\Documents\\Tunisys\\node_modules\\html-to-image\\src\\embed-images.ts"],"sourcesContent":["import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}