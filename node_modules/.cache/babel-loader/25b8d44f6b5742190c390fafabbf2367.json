{"ast":null,"code":"import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\n\nasync function cloneCanvasElement(canvas) {\n  const dataURL = canvas.toDataURL();\n\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false);\n  }\n\n  return createImage(dataURL);\n}\n\nasync function cloneVideoElement(video, options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.width = video.clientWidth;\n    canvas.height = video.clientHeight;\n    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n    const dataURL = canvas.toDataURL();\n    return createImage(dataURL);\n  }\n\n  const poster = video.poster;\n  const contentType = getMimeType(poster);\n  const dataURL = await resourceToDataURL(poster, contentType, options);\n  return createImage(dataURL);\n}\n\nasync function cloneIFrameElement(iframe) {\n  var _a;\n\n  try {\n    if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n      return await cloneNode(iframe.contentDocument.body, {}, true);\n    }\n  } catch (_b) {// Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false);\n}\n\nasync function cloneSingleNode(node, options) {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node);\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options);\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node);\n  }\n\n  return node.cloneNode(false);\n}\n\nconst isSlotElement = node => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\n\nasync function cloneChildren(nativeNode, clonedNode, options) {\n  var _a, _b;\n\n  let children = [];\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray(nativeNode.assignedNodes());\n  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n    children = toArray(nativeNode.contentDocument.body.childNodes);\n  } else {\n    children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n  }\n\n  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n    return clonedNode;\n  }\n\n  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then(clonedChild => {\n    if (clonedChild) {\n      clonedNode.appendChild(clonedChild);\n    }\n  }), Promise.resolve());\n  return clonedNode;\n}\n\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n  const targetStyle = clonedNode.style;\n\n  if (!targetStyle) {\n    return;\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode);\n\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText;\n    targetStyle.transformOrigin = sourceStyle.transformOrigin;\n  } else {\n    toArray(sourceStyle).forEach(name => {\n      let value = sourceStyle.getPropertyValue(name);\n\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n        value = `${reducedFont}px`;\n      }\n\n      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === 'display' && value === 'inline') {\n        value = 'block';\n      }\n\n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`;\n      }\n\n      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n    });\n  }\n}\n\nfunction cloneInputValue(nativeNode, clonedNode) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value;\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value);\n  }\n}\n\nfunction cloneSelectValue(nativeNode, clonedNode) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode;\n    const selectedOption = Array.from(clonedSelect.children).find(child => nativeNode.value === child.getAttribute('value'));\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '');\n    }\n  }\n}\n\nfunction decorate(nativeNode, clonedNode) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode);\n    clonePseudoElements(nativeNode, clonedNode);\n    cloneInputValue(nativeNode, clonedNode);\n    cloneSelectValue(nativeNode, clonedNode);\n  }\n\n  return clonedNode;\n}\n\nasync function ensureSVGSymbols(clone, options) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n\n  if (uses.length === 0) {\n    return clone;\n  }\n\n  const processedDefs = {};\n\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i];\n    const id = use.getAttribute('xlink:href');\n\n    if (id) {\n      const exist = clone.querySelector(id);\n      const definition = document.querySelector(id);\n\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = await cloneNode(definition, options, true);\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs);\n\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml';\n    const svg = document.createElementNS(ns, 'svg');\n    svg.setAttribute('xmlns', ns);\n    svg.style.position = 'absolute';\n    svg.style.width = '0';\n    svg.style.height = '0';\n    svg.style.overflow = 'hidden';\n    svg.style.display = 'none';\n    const defs = document.createElementNS(ns, 'defs');\n    svg.appendChild(defs);\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i]);\n    }\n\n    clone.appendChild(svg);\n  }\n\n  return clone;\n}\n\nexport async function cloneNode(node, options, isRoot) {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null;\n  }\n\n  return Promise.resolve(node).then(clonedNode => cloneSingleNode(clonedNode, options)).then(clonedNode => cloneChildren(node, clonedNode, options)).then(clonedNode => decorate(node, clonedNode)).then(clonedNode => ensureSVGSymbols(clonedNode, options));\n}","map":{"version":3,"mappings":"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","names":["clonePseudoElements","createImage","toArray","isInstanceOfElement","getMimeType","resourceToDataURL","cloneCanvasElement","canvas","dataURL","toDataURL","cloneNode","cloneVideoElement","video","options","currentSrc","document","createElement","ctx","getContext","width","clientWidth","height","clientHeight","drawImage","poster","contentType","cloneIFrameElement","iframe","contentDocument","_a","body","cloneSingleNode","node","HTMLCanvasElement","HTMLVideoElement","HTMLIFrameElement","isSlotElement","tagName","toUpperCase","cloneChildren","nativeNode","clonedNode","children","assignedNodes","childNodes","shadowRoot","_b","length","reduce","deferred","child","then","clonedChild","appendChild","Promise","resolve","cloneCSSStyle","targetStyle","style","sourceStyle","window","getComputedStyle","cssText","transformOrigin","forEach","name","value","getPropertyValue","endsWith","reducedFont","Math","floor","parseFloat","substring","getAttribute","setProperty","getPropertyPriority","cloneInputValue","HTMLTextAreaElement","innerHTML","HTMLInputElement","setAttribute","cloneSelectValue","HTMLSelectElement","clonedSelect","selectedOption","Array","from","find","decorate","Element","ensureSVGSymbols","clone","uses","querySelectorAll","processedDefs","i","use","id","exist","querySelector","definition","nodes","Object","values","ns","svg","createElementNS","position","overflow","display","defs","isRoot","filter"],"sources":["C:\\Users\\donia\\Documents\\Tunisys\\node_modules\\html-to-image\\src\\clone-node.ts"],"sourcesContent":["import type { Options } from './types'\nimport { clonePseudoElements } from './clone-pseudos'\nimport { createImage, toArray, isInstanceOfElement } from './util'\nimport { getMimeType } from './mimes'\nimport { resourceToDataURL } from './dataurl'\n\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\n  const dataURL = canvas.toDataURL()\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false) as HTMLCanvasElement\n  }\n  return createImage(dataURL)\n}\n\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    canvas.width = video.clientWidth\n    canvas.height = video.clientHeight\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\n    const dataURL = canvas.toDataURL()\n    return createImage(dataURL)\n  }\n\n  const poster = video.poster\n  const contentType = getMimeType(poster)\n  const dataURL = await resourceToDataURL(poster, contentType, options)\n  return createImage(dataURL)\n}\n\nasync function cloneIFrameElement(iframe: HTMLIFrameElement) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return (await cloneNode(\n        iframe.contentDocument.body,\n        {},\n        true,\n      )) as HTMLBodyElement\n    }\n  } catch {\n    // Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false) as HTMLIFrameElement\n}\n\nasync function cloneSingleNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<HTMLElement> {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node)\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options)\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node)\n  }\n\n  return node.cloneNode(false) as T\n}\n\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\n\nasync function cloneChildren<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  options: Options,\n): Promise<T> {\n  let children: T[] = []\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray<T>(nativeNode.assignedNodes())\n  } else if (\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n    nativeNode.contentDocument?.body\n  ) {\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\n  } else {\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\n  }\n\n  if (\n    children.length === 0 ||\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\n  ) {\n    return clonedNode\n  }\n\n  await children.reduce(\n    (deferred, child) =>\n      deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild: HTMLElement | null) => {\n          if (clonedChild) {\n            clonedNode.appendChild(clonedChild)\n          }\n        }),\n    Promise.resolve(),\n  )\n\n  return clonedNode\n}\n\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  const targetStyle = clonedNode.style\n  if (!targetStyle) {\n    return\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode)\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\n  } else {\n    toArray<string>(sourceStyle).forEach((name) => {\n      let value = sourceStyle.getPropertyValue(name)\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont =\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\n        value = `${reducedFont}px`\n      }\n\n      if (\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        name === 'display' &&\n        value === 'inline'\n      ) {\n        value = 'block'\n      }\n      \n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`\n      }\n      \n      targetStyle.setProperty(\n        name,\n        value,\n        sourceStyle.getPropertyPriority(name),\n      )\n    })\n  }\n}\n\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value)\n  }\n}\n\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode as any as HTMLSelectElement\n    const selectedOption = Array.from(clonedSelect.children).find(\n      (child) => nativeNode.value === child.getAttribute('value'),\n    )\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '')\n    }\n  }\n}\n\nfunction decorate<T extends HTMLElement>(nativeNode: T, clonedNode: T): T {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode)\n    clonePseudoElements(nativeNode, clonedNode)\n    cloneInputValue(nativeNode, clonedNode)\n    cloneSelectValue(nativeNode, clonedNode)\n  }\n\n  return clonedNode\n}\n\nasync function ensureSVGSymbols<T extends HTMLElement>(\n  clone: T,\n  options: Options,\n) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\n  if (uses.length === 0) {\n    return clone\n  }\n\n  const processedDefs: { [key: string]: HTMLElement } = {}\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i]\n    const id = use.getAttribute('xlink:href')\n    if (id) {\n      const exist = clone.querySelector(id)\n      const definition = document.querySelector(id) as HTMLElement\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = (await cloneNode(definition, options, true))!\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs)\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml'\n    const svg = document.createElementNS(ns, 'svg')\n    svg.setAttribute('xmlns', ns)\n    svg.style.position = 'absolute'\n    svg.style.width = '0'\n    svg.style.height = '0'\n    svg.style.overflow = 'hidden'\n    svg.style.display = 'none'\n\n    const defs = document.createElementNS(ns, 'defs')\n    svg.appendChild(defs)\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i])\n    }\n\n    clone.appendChild(svg)\n  }\n\n  return clone\n}\n\nexport async function cloneNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n  isRoot?: boolean,\n): Promise<T | null> {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null\n  }\n\n  return Promise.resolve(node)\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\n    .then((clonedNode) => decorate(node, clonedNode))\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\n}\n"]},"metadata":{},"sourceType":"module"}